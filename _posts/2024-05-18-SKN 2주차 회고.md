---
title: SK네트웍스 Family AI 캠프 1기 2주차 회고
date: 2024-05-18 13:08:40 +09:00
categories: [SKN AI Camp, Remind]
tags: 
    [
        SKN AI Camp,
        SK네트웍스 Family AI 캠프,
        회고,
        Weekly 회고
    ]
---

# SK Networks AI Camp
![Main image](https://github.com/Jh-jaehyuk/Jh-jaehyuk.github.io/assets/126551524/7ea63fc3-95f0-44d5-a0f0-cf431cae34f1){: .align-center}  

## Weekly 회고 - 2주차  
  
:warning: 포스트를 읽기 전에..  
이 포스트는 SK네트웍스 Family AI 캠프를 다니면서 느낀 개인적인 생각을 정리한 포스트입니다.  
배운 내용이나 스킬셋에 대한 설명은 별도로 작성하지 않았기 때문에, 그에 대한 정보는 다른 포스트를 참고해주세요!
  
  

### :thumbsup:Liked
우선 강의 외적으로 좋았던 점이 있어서 말하고자 합니다. 저번주 회고 쓸 때까진 몰랐었는데, 캠퍼스에 무려 **커피가 무제한 제공**이라고 하더라구요! 커피 애호가인 저로써는 이보다 더 좋은 복지가 없다고 생각합니다. :satisfied:  
이제 강의 내용으로 돌아가서, 이번주 강의에서 첫 번째로 좋았던 점은 Visual Studio code 이외에 **jupyter notebook**을 사용하기 시작했다는 점입니다. VS code가 분명 좋은 IDE인 것은 맞지만, 앞으로 데이터베이스와 데이터 분석을 배운다는 것을 생각해보면 시각화에 강점이 있는 jupyter notebook도 사용해보는 것이 좋다고 생각했기 때문입니다.  
그렇다면 데이터 분석을 하는 데 왜 시각화가 중요할까요? 데이터 분석은 데이터프레임과 그래프 등을 이용하여 이상치 또는 결측치를 파악하고 데이터 전처리를 하는 것이 중요하기 때문입니다. 그리고 보통 하나의 데이터 파일에 적게는 수 천개, 많게는 몇 백만개의 데이터가 들어있어 일반적인 IDE를 사용하면 필요할 때마다 그래프를 새로 그리는 데 시간이 오래 걸린다는 단점이 있습니다. 하지만 jupyter notebook은 코드를 실행시키면 실행 결과가 해당 코드 블록 아래에 남게 되어, 그래프를 다시 확인 할 때 코드를 다시 실행하지 않아도 된다는 장점이 있습니다.  
두 번째로 좋았던 점은 드디어 파이썬 기초 내용이 끝났다는 점입니다!:clap::clap::clap:  
![meme image1](https://github.com/Jh-jaehyuk/Jh-jaehyuk.github.io/assets/126551524/574f0aa0-43ef-43aa-aaaf-8c82bab0960d){: .align-center}  
  
이제 정식으로 파이썬을 배운 사람이라고 할 수 있게 되었습니다. 사실 정확히는 파이썬 기초가 끝났다는 점이 좋다는 것보다는 다음 커리큘럼인 **데이터베이스**를 배울 수 있게 되었다는 게 좋은 점이라고 할 수 있습니다. 데이터베이스는 캠프에 참여하기 전, 가볍게 SQL을 공부해본 것이 전부라서 어떤 것을 배우더라도 다 처음 들어보는 내용이기 때문입니다. 데이터베이스 내용을 배워서 곧 진행하게 될 프로젝트에 성공적으로 적용해보는 것이 목표입니다!
![meme image2](https://github.com/Jh-jaehyuk/Jh-jaehyuk.github.io/assets/126551524/ceae177d-3522-44d1-b7b1-ea9b084b25a1){: .align-center}  
  

### :books:Learned
이번 주는 jupyter notebook을 배우는 것을 시작으로 파이썬에서 예외 처리하는 방법을 배웠습니다. 평소 사이드 프로젝트를 진행할 때에도 별도의 예외 처리를 해본 적이 없어서 "굳이 예외 처리가 필요한가?" 라는 생각을 가지고 있었습니다. 하지만 강의를 듣다보니 혼자서 진행하는 사이드 프로젝트와 달리, 실제 업무 프로젝트는 여러 명이 같이 작업하는 일이 많고 프로젝트를 진행한 사람이 사용하는 것이 아니라 일반인이 사용하기 때문에 어떤 일이 발생할 지 모른다 라는 생각을 갖게 되었습니다. 다음과 같은 예시를 들어보겠습니다.   

```py
number_list = [10, 20, 30, 40, 50]

number = int(input("숫자를 입력해주세요: "))
print(number_list.index(number))
```
  
위와 같이, 리스트에서 숫자를 하나 선택하면 그 숫자가 들어있는 인덱스를 반환하는 프로그램을 만든다고 생각해봅시다. 제가 코드를 짜고, 제가 프로그램을 사용하는 사람이라면 당연히 리스트 안에 있는 숫자만 선택할 것입니다. 하지만, 아무 것도 모르는 일반인이 사용한다고 하면 단순 재미로 리스트에 있지 않은 숫자를 선택할 수도 있을 것입니다. 그렇다면 파이썬 인터프리터는 리스트에 없는 숫자를 탐색하게 될 것이고 결국 *ValueError*를 발생시킬 것입니다. 이런 경우를 방지하려면 어떻게 해야될까요?  

```py
number_list = [10, 20, 30, 40, 50]

try:
    number = int(input("숫자를 입력해주세요: "))
    print(number_list.index(number))
except ValueError as e: # ValueError가 발생한다면
    print("리스트에 존재하는 숫자만 입력해주세요!")
    print("exception:", e)
```
  
위와 같은 방식으로 예외 처리를 하게 되면, 사용자로 하여금 "아 내가 리스트에 없는 숫자를 입력해서 프로그램 오류가 발생했구나!" 라는 것을 인지하게 할 수 있습니다. 사용자가 문제를 인식하면 같은 일이 반복되지 않도록 프로그램을 사용하게 될 것입니다. 이 방법뿐만 아니라 **raise**구문을 사용하여 비슷한 결과를 도출해낼 수도 있습니다.  

```py
number_list = [10, 20, 30, 40, 50]

number = int(input("숫자를 입력해주세요: "))
if number not in number_list:
    print("리스트에 존재하는 숫자만 입력해주세요!")
    raise ValueError
else:
    print(number_list.index(number)
```
  
위와 같이 raise 구문을 사용하면 개발자가 원치 않는 경우에 대하여 원하는 오류 결과를 보여줄 수 있게 됩니다. 이런 식으로 예외 처리를 적극적으로 이용하면 사용자에게 문제점을 보다 쉽게 전달할 수 있다는 장점이 존재한다는 것을 알게 되었습니다.  
그 다음으로 operator와 BeautifulSoup, flask 사용하며 모듈에 대해 배웠습니다. 모듈을 설치하고 사용하는 것은 캠프에 참여하기 전에도 경험해보았기 때문에 크게 어려운 점은 없었지만, 폴더 내부에 생성해주는 \__init__.py 파일에 대해 배운 것이 있습니다. \__init__.py 파일은 폴더 내부에 생성해주어 폴더 내부의 py 파일들을 한번에 import 할 수 있게 해주는 역할을 합니다. 아래와 같은 구 조의 폴더가 있다고 해봅시다.  

```
|
├--- package
|       ├---- __init__.py
|       ├---- module1.py
|       └---- module2.py
└--- main.py
```
  

\__init__.py 파일이 없다면 main.py에서 module1.py 와 module2.py를 이용하기 위해선 아래와 같이 작성해야 합니다.  

```py
# main.py

import package.module1
import package.module2
```
  
하지만, \__init__.py를 작성한다면 아래와 같이 사용할 수 있습니다. 우선 \__init__.py 를 작성해보겠습니다.  

```py
# __init__.py

__all__ = ["module1", "module2"] # 모듈을 불러올 때 가져올 모듈 목록
```
  
이어서, main.py를 작성해보겠습니다.  

```py
# main.py

from package import * # package 폴더에 있는 모든 모듈을 가져옵니다
```
  
위 처럼 폴더 하나에 두 개의 모듈만 있는 경우엔 큰 차이가 없다고 느껴지겠지만, 폴더에 수 십개의 모듈이 있다고 하면 그 모듈들에 대해 일일이 import 하는 것보단 \__init__.py 하나만 추가로 작성하는 것이 편할 것이라고 생각합니다.  
그 다음으로는 파이썬 기초의 마지막 내용인 클래스에 대해 배웠습니다. 클래스는 캠프에 참여하기 이전, CNN을 공부하면서 자주 다루어보았던 내용이라서 한 가지 내용을 제외하곤 알고 있던 내용을 정리하는 느낌으로 강의를 들었습니다. 새로 알게된 한 가지 내용은 클래스 내부에 작성하는 메서드인 *new* 메서드입니다. new 메서드는 클래스 내부에 \__new__()의 형태로 작성하게 되는데, new 메서드에서 반환하는 값을 클래스가 인스턴스로 가지게 되는 특이한(?) 메서드입니다. 이 또한 말로는 감이 잘 오지 않기 때문에, 예시를 통해 알아보도록 하겠습니다.  

```py
class Evil():
    def __new__(cos, *args):
         return 1

evil = Evil() # Evil 클래스를 인스턴스화
isinstance(evil, Evil) # 그렇다면 evil은 Evil 클래스의 인스턴스일까?
```
  
위와 같이 작성한 코드의 결과값은 신기하게도 *False*입니다.. 분명히 evil은 Evil 클래스를 인스턴스화한 변수인데, 왜 이런 결과가 나타난 것일까요? 그 해답은 Evil 클래스 내부의 \__new__() 메서드에 있습니다. 위에서 언급했듯 new 메서드를 이용하면 그 클래스는 new 메서드에서 반환하는 값을 인스턴스로 갖게 됩니다. 그렇기 때문에 evil은 Evil을 인스턴스화한 변수이지만 Evil의 인스턴스가 아닌 int의 인스턴스가 되는 것입니다. 이를 확인하기 위해선 아래와 같은 코드를 실행해보면 됩니다.  

```py
class Evil():
    def __new__(cos, *args):
         return 1

evil = Evil() # Evil 클래스를 인스턴스화
isinstance(evil, int) # __new__() 가 int를 반환하기 때문에 int의 인스턴스이다.
```
  
위 코드의 결과값은 앞서 말한것과 같이 *True*입니다. 그렇다면 new 메서드를 이용하면서 그 클래스의 인스턴스를 갖게 하려면 어떻게 해야할까요? 검색을 통해 알아본 결과 아래와 같이 작성하면 new 메서드를 이용하면서도 Evil 인스턴스를 갖게 할 수 있음을 알게 되었습니다.  

```py
class Evil():
    def __new__(cos, *args):
         return super().__new__(cls)

evil = Evil() # Evil 클래스를 인스턴스화
isinstance(evil, Evil)
```
  
위 코드의 결과값은 *True*입니다. 이처럼 new 메서드는 생각과 다른 결과가 나오기에 사용에 주의해야함을 배웠습니다.  
이 외에도 simplegui와 streamlit 이라는 패키지를 설치해보고 가져와서 사용해보기도 하였지만 새롭게 알게된 내용은 없는 것 같아 따로 작성하진 않았습니다.  
  
  
### :face_with_spiral_eyes:Lacked
2주차 커리큘럼을 진행해본 결과, 스스로 느낀 부족한 점은 "세밀함"이라고 생각합니다. 이번 주차에 배운 내용들이 아예 처음 들어보는 내용이 아님에도 불구하고, 제가 모르는 내용들이 존재했기 때문입니다. 여태까지 모듈이든 클래스든 작성하고 사용하는 데에는 큰 무리가 없었기 때문에 스스로 모두 알고 있을 것이라고 생각했던 것이 앞서 언급한 세밀함 부족이라고 생각합니다. 회고록을 작성하며 든 생각인데, 회고록을 작성하며 스스로 부족한 부분을 돌아볼 수 있어 다시 한 번 겸손한 자세로 캠프에 임할 수 있는 동기부여가 되는 것 같아 기분이 좋습니다. 이번 주에 스스로 느낀 것을 바탕으로 다음 주에 배우게 될 데이터베이스는 보다 섬세하고 꼼꼼하게 공부할 예정입니다!:100:
  

### :thought_balloon:Longed for
저번 주에 한가지 툴만 이용했기 때문에 새로운 툴을 이용했으면 좋겠다고 작성했었는데, 이번 주에 마침 jupyter notebook을 배우게 되어 매우 만족스럽습니다. 한 가지 새롭게 바라는 점이 있다면, 강의의 짜임새가 조금 더 있었으면 합니다. 조금 더 구체적으로 말씀드리자면, 강사님이 강의하시는 내용에 대해 직접 자료를 만들어서 사용하셨으면 하는 바람이 있습니다.  
그 이유는 이번 주에 모듈, 클래스 강의 자료라고 올려주신 파일로 강의를 진행하셨는데 '혼자 공부하는 파이썬' 책의 내용과 순서도 다르고 설명도 없이 코드만 있는 자료여서 보기 불편했기 때문입니다. 아마 책과 내용이 상이한 것으로 보아 책을 바탕으로 작성하신 것이 아닌 다운받으신 파일이 아닌가 합니다. 전공자분들은 어차피 아는 내용이기 때문에 크게 강의를 듣는데 무리가 없겠지만, 이 강의가 비전공자분들도 듣는 강의임을 고려하면 그런 강의 자료는 크게 도움이 되지 않는다고 생각합니다.  
앞으로 커리큘럼이 지금보다 훨씬 어려워질 것을 감안한다면 당연히 수정되어야 할 부분이라고 생각하여 바라는 점에 적어보았습니다.  
  
- - -
### 맺음말
![meme image3](https://github.com/Jh-jaehyuk/Jh-jaehyuk.github.io/assets/126551524/e2a679ab-ee8a-4882-8985-47292f8883ff){: .align-center}  
저번주 회고록은 처음 작성하는 것이라 너무 딱딱하게 작성한 것 같다는 생각이 들어, 이번주 회고록은 보다 가벼운 마음으로 작성해보았습니다. 다른 분들이 이 블로그 글을 보실지 모르겠으나 평일 내내 공부하는동안 경직되어 있으니 한 주의 마무리인 회고록정도는 웃으면서 작성해도 좋지 않을까 하는 생각이 해봅니다..! 다들 이번 주도 고생 많으셨습니다. 다음 주도 같이 힘내보아요:grin:  
ps. 혹시 깃 블로그 이미지 크기 줄이면서 가운데 정렬도 맞출 수 있는 방법을 알고계신 분이 있다면 알려주세요:sob:

