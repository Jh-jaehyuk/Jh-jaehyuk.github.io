---
title: SK네트웍스 Family AI 캠프 1기 9주차 회고
date: 2024-07-06 13:16:43 +09:00
categories: [SKN AI Camp, Remind]
tags: 
    [
        SKN AI Camp,
        SK네트워크 AI 캠프,
        회고,
        Weekly 회고
    ]
---

# SK Networks AI Camp
![Main image](https://github.com/Jh-jaehyuk/Jh-jaehyuk.github.io/assets/126551524/7ea63fc3-95f0-44d5-a0f0-cf431cae34f1){: .align-center}  

## Weekly 회고 - 9주차  
  
:warning: 포스트를 읽기 전에..  
이 포스트는 SK네트웍스 Family AI 캠프를 다니면서 느낀 개인적인 생각을 정리한 포스트입니다.  
배운 내용이나 스킬셋에 대한 설명은 별도로 작성하지 않았기 때문에, 그에 대한 정보는 다른 포스트를 참고해주세요!
  
  
### :thumbsup:Liked
7월의 첫번째 회고입니다! 벌써 *9주차 회고*를 작성하고 있다는 건 제가 9주차동안 잘 버텨냈다는 것이겠죠? 앞으로도 제가 잘 버텼으면 좋겠습니다.:grin:  
이번 주 좋았던 점은 **Django와 Vue + TypeScript를 이용해서 코드를 작성하는 방식**을 어느정도 깨달은 것 같다는 기분이 들었다는 점입니다.  
*"그게 무슨 말이냐"* 하실 수 있어서 간단히 설명을 드리자면, 지금까지도 코드를 짜긴했지만 강의에서 작성한 방식을 벗어나지 못하고 코드를 짠다는 생각을 
하곤 했습니다. 코드를 짠다고 하긴하지만 강의에서 사용한 코드를 약간 수정하거나 변수를 살짝 바꾸는 정도라고 생각하시면 될 것 같습니다.  
하지만, 이번 주에 팀 과제를 진행하며 강의에서 다루지 않은 기능을 구현해보려고 시도하는 과정에서 혼자 고민하고 알아보고 하는 시간이 길었습니다.  
그 과정에서 서버와 클라이언트가 어떤 식으로 통신이 이루어지는지 미숙하지만 약간은 감을 잡은 것 같습니다. 제가 이해한 것이 실제로 맞는 것인지 
알아보기 위해선 직접 코드를 짜서 구현해보는 방법밖에 없었고, 이번 주 내내 고생을 하긴 했지만 구현을 해내긴 했습니다!  
(어떤 것을 구현했는지 자랑하기엔 너무 부족한 결과물이라 다음 기회에..:sob:)
  
---
### :books:Learned
**이번주에 배운 내용**들은 아래와 같습니다.
* Gradient Descent(경사 하강법)
* Decision Forest
* Principal Components Analysis(PCA, 주성분 분석)
* Convolutional Neural Network(CNN, 합성곱 신경망)

원래는 5개여야 하지만, 이번 주는 제가 예비군을 다녀와서 하루 결석한 관계로 4개밖에 없습니다!  
위의 4가지 중에서 기존에 공부해봤던 1, 4번을 제외하고 2, 3번에 대한 내용을 간략하게 정리해보고자 합니다.  
  
1. **Decision Forest**  
Decision Forest는 Tensorflow에서 제공하는 라이브러리입니다. Decision Tree와 이름이 비슷하여 헷갈릴 수 있어서 두 개의 차이점을 위주로 작성하고자 합니다!  

TensorFlow Decision Forests (TF-DF)와 Decision Tree는 둘 다 의사결정 트리 알고리즘을 활용하지만, 다음과 같은 차이점이 있습니다:  
#### 1. **개념 및 목적**
- **Decision Tree**:
  - **개념**: 데이터 분류 및 회귀 문제를 해결하기 위해 사용하는 트리 구조 모델.
  - **목적**: 데이터를 속성에 따라 분할하여 예측 정확도를 높임.
  - **사용 예**: 단일 트리로 데이터의 분포를 모델링하여 예측.
  
- **TensorFlow Decision Forests (TF-DF)**:
  - **개념**: TensorFlow 프레임워크 내에서 다양한 결정 트리 알고리즘(랜덤 포레스트, 그라디언트 부스팅 등)을 사용하여 강력한 예측 모델을 생성하는 라이브러리.
  - **목적**: 대규모 데이터에 대해 고성능 예측을 제공하고 TensorFlow와 통합하여 딥러닝 모델과의 결합을 가능하게 함.
  - **사용 예**: 앙상블 방법을 활용하여 다수의 트리를 결합해 더 나은 예측 성능을 제공.

#### 2. **기술적 차이점**
- **Decision Tree**:
  - **단일 트리**: 하나의 트리 구조로 모델링.
  - **단순성**: 이해하고 해석하기 쉬움.
  - **과적합 문제**: 깊이가 깊어질수록 과적합 가능성 높음.
  
- **TensorFlow Decision Forests (TF-DF)**:
  - **앙상블 기법**: 여러 트리(랜덤 포레스트, 그라디언트 부스팅)를 사용하여 개별 트리의 예측을 결합함으로써 성능 향상.
  - **TensorFlow 통합**: 딥러닝 모델과 결합하여 하이브리드 모델 구축 가능.
  - **확장성**: 대규모 데이터셋과 복잡한 모델을 효율적으로 처리 가능.
  
#### 3. **사용 방법 및 환경**
- **Decision Tree**:
  - **독립적 사용**: Scikit-learn과 같은 라이브러리를 사용하여 독립적으로 사용.
  - **제약**: 단일 트리로 인해 성능 한계가 있을 수 있음.
  
- **TensorFlow Decision Forests (TF-DF)**:
  - **TensorFlow 환경**: TensorFlow 생태계 내에서 사용, 다른 TensorFlow 모델과 쉽게 통합 가능.
  - **고급 기능**: 하이퍼파라미터 튜닝, 고급 분류 및 회귀 기법 지원.
  
#### 4. **성능 및 적용 사례**
- **Decision Tree**:
  - **적용 사례**: 작은 데이터셋 및 단순한 문제에 적합.
  - **성능**: 앙상블 기법에 비해 일반적으로 낮음.
  
- **TensorFlow Decision Forests (TF-DF)**:
  - **적용 사례**: 대규모 데이터셋 및 복잡한 문제에 적합.
  - **성능**: 높은 성능을 제공하며, 특히 대규모 데이터 및 복잡한 데이터 구조에서 뛰어남.
  
결론적으로, *Decision Tree*는 단일 트리 기반의 간단하고 직관적인 모델인 반면, *TensorFlow Decision Forests*는 앙상블 기법을 활용하여 더 복잡하고 높은 성능을 제공하는 모델입니다. 
TF-DF는 특히 TensorFlow와의 통합을 통해 딥러닝 모델과의 결합을 가능하게 하여, 더욱 강력하고 유연한 머신러닝 솔루션을 제공합니다.

2. **Principal Compoenents Analaysis**  
Principal Components Analysis (PCA, 주성분 분석)은 고차원 데이터의 차원을 축소하는 데 사용되는 통계 기법입니다.
주성분 분석은 데이터의 분산을 최대화하는 새로운 좌표계를 찾아 데이터의 중요한 구조를 발견하고 시각화하거나, 데이터 압축 및 노이즈 제거에 도움을 줍니다.  

#### PCA의 주요 개념 및 과정

1. **목적**:
   - **차원 축소**: 고차원 데이터를 더 적은 차원으로 변환하여 데이터의 구조를 더 잘 이해하고 시각화할 수 있도록 돕습니다.
   - **특징 추출**: 데이터의 가장 중요한 특성을 추출하여 분석 성능을 향상시킵니다.
   - **노이즈 제거**: 데이터의 노이즈를 줄여 중요한 정보만을 남깁니다.

2. **주요 개념**:
   - **주성분 (Principal Components)**: 데이터의 분산을 최대화하는 새로운 축입니다. 첫 번째 주성분은 데이터의 분산이 가장 큰 방향을 나타내고, 
   두 번째 주성분은 첫 번째 주성분에 직교하면서 그 다음으로 큰 분산을 설명하는 방향을 나타냅니다. 이런 식으로 k번째 주성분까지 계산합니다.
   - **고유벡터 (Eigenvectors)와 고유값 (Eigenvalues)**: 공분산 행렬의 고유벡터가 주성분의 방향을 나타내고, 고유값이 각 주성분의 중요도를 나타냅니다.

3. **과정**:
   1. **데이터 정규화**: 각 특징을 평균이 0이고 분산이 1이 되도록 정규화합니다.
   2. **공분산 행렬 계산**: 정규화된 데이터의 공분산 행렬을 계산합니다.
   3. **고유값 및 고유벡터 계산**: 공분산 행렬의 고유값과 고유벡터를 계산합니다.
   4. **주성분 선택**: 고유값을 내림차순으로 정렬하고, 가장 큰 k개의 고유값에 해당하는 고유벡터를 선택합니다.
   5. **데이터 변환**: 선택된 고유벡터를 사용하여 원본 데이터를 새로운 k차원 공간으로 변환합니다.

#### PCA의 장점
- **시각화**: 고차원 데이터를 2차원 또는 3차원으로 축소하여 시각화할 수 있습니다.
- **특징 추출**: 중요한 특징을 추출하여 데이터의 주요 패턴을 파악할 수 있습니다.
- **노이즈 제거**: 데이터를 단순화하여 노이즈의 영향을 줄일 수 있습니다.
- **연산 효율성**: 차원 축소로 인해 계산 비용을 절감할 수 있습니다.

#### PCA의 단점
- **해석의 어려움**: 주성분은 원본 특징의 선형 결합이기 때문에 해석이 어려울 수 있습니다.
- **선형성 가정**: PCA는 선형 변환을 기반으로 하므로 비선형 관계를 잘 설명하지 못합니다.
- **정보 손실**: 차원을 축소하면서 일부 정보가 손실될 수 있습니다.

#### 예시

1. **데이터 준비 및 정규화**:
    ```python
   from sklearn.preprocessing import StandardScaler
   from sklearn.decomposition import PCA
   import numpy as np

   # 예시 데이터 생성
   X = np.array([[2.5, 2.4],
                 [0.5, 0.7],
                 [2.2, 2.9],
                 [1.9, 2.2],
                 [3.1, 3.0],
                 [2.3, 2.7],
                 [2, 1.6],
                 [1, 1.1],
                 [1.5, 1.6],
                 [1.1, 0.9]])

   # 데이터 정규화
   X_std = StandardScaler().fit_transform(X)
    ```

2. **PCA 수행**:
    ```python
   pca = PCA(n_components=2)
   principalComponents = pca.fit_transform(X_std)
   print(principalComponents)
    ```

위 예시에서는 2차원 데이터를 PCA로 변환한 후 새로운 축에 대한 데이터를 출력합니다.  

#### PCA가 데이터의 노이즈를 제거한다는 것의 의미
PCA가 데이터의 노이즈를 줄인다는 의미는 차원 축소 과정에서 데이터의 중요한 정보만을 남기고, 상대적으로 덜 중요한 정보를 제거하여 노이즈(잡음)를 줄이는 것을 의미합니다. 
이를 이해하기 위해 몇 가지 주요 포인트를 살펴보겠습니다:

1. **주성분의 선택**
PCA는 데이터의 분산을 최대화하는 방향(주성분)을 찾습니다. 주성분은 데이터의 변동성을 설명하는 순서대로 배열되며, 
첫 번째 주성분이 가장 큰 분산을 설명하고, 그 다음 주성분이 그 다음으로 큰 분산을 설명합니다.

2. **분산과 정보**
데이터의 주요 구조는 보통 높은 분산을 나타내는 방향에 있습니다. 노이즈는 데이터의 작은 변동을 나타내는 경우가 많아 상대적으로 낮은 분산을 가집니다. 
PCA는 이러한 특성을 이용해 중요한 정보를 유지하고 노이즈를 제거합니다.

3. **차원 축소와 노이즈 제거**
PCA는 고차원 데이터를 소수의 주성분으로 변환하면서, 주성분의 개수를 줄이는 방식으로 차원 축소를 수행합니다. 이 과정에서 낮은 분산을 가진 주성분, 
즉 노이즈가 많은 방향을 제거하게 됩니다. 이렇게 하면 데이터의 주요 패턴과 구조는 유지되면서 노이즈가 줄어들게 됩니다.

* **예시로 살펴보는 노이즈 제거 과정**

1. **원본 데이터**
   - 고차원 데이터는 여러 변수를 포함하고 있으며, 각 변수에는 중요한 정보뿐만 아니라 노이즈도 포함되어 있습니다.
   
2. **주성분 분석(PCA)**
   - 데이터의 공분산 행렬을 계산하고, 고유값 분해를 통해 주성분을 찾습니다.
   - 고유값이 큰 주성분은 데이터의 중요한 변동을 나타내고, 고유값이 작은 주성분은 주로 노이즈를 나타냅니다.

3. **차원 축소**
   - 고유값이 큰 몇 개의 주성분만을 선택하여 데이터를 저차원 공간으로 변환합니다.
   - 이때 제거된 주성분은 대부분 노이즈 성분이므로, 데이터의 노이즈가 줄어듭니다.
  
#### 결론
PCA는 고차원 데이터의 구조를 이해하고 시각화하기 위해 널리 사용되는 기법입니다. 
데이터의 중요한 특성을 유지하면서 차원을 축소함으로써 분석 성능을 향상시키고 노이즈를 줄일 수 있습니다. 
하지만 PCA는 선형성 가정과 해석의 어려움 등의 단점을 가지므로, 다른 비선형 차원 축소 기법과 함께 사용될 수 있습니다.
  
---
### :face_with_spiral_eyes:Lacked
이번 주에 부족했던 점은 알고리즘 문제를 풀지 못했다는 점입니다. 아무리 시간이 없다고해도 하루에 30분 ~ 1시간정도는 빼서 문제풀이에 사용했어야 하는데
시간을 효율적으로 사용하지 못한 것 같아서 아쉬움이 남습니다.  
그리고 한 가지 더, 주말마다 비전공자인 팀원을 만나서 도와주려고 했는데 피곤함이 너무 쌓이고 과제 진척도도 생각보다 느려서 시간을 내지 못했습니다. 
제가 이번 팀 과제 끝나기 전까지 팀원의 역량을 많이 높여줄 수 있을줄 알았는데 제가 잘 설명하는 사람이 아니라는 것이 아쉽습니다. 
그래도 아직 팀이 바뀐건 아니기 때문에 마지막까지 열심히 해보도록 하겠습니다!:fire:
  
---
### :thought_balloon:Longed for
이번 주 이후로 스스로에게 바라는 점은 제가 더 빠르게 실력을 늘리고 설명하는 방식을 보완해서 진도를 따라가기 벅찬 사람들을 도와줄 수 있었으면 합니다.  
그러면서도 개인적인 공부를 소홀히 하지 않는 사람이 되고 싶습니다! 알고리즘 공부는 물론이고, 최근 '**Rust**' 라는 언어에도 관심이 생겨서 간단한 
사용법정도는 익혀두면 좋겠다는 생각도 있습니다.  
욕심일지도 모르지만 바램은 이정도로 크게 잡아도 괜찮지않나 라는 생각입니다!   
앞으로도 꾸준히 발전하는 사람이 되도록 노력하겠습니다.